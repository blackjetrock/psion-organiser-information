<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Psion Organiser 1 Finance Pack Manual - Jaap's Psion Organiser II Page</title>
<link rel="stylesheet" type="text/css" href="psion.css">
<link rel="shortcut icon" href="pics/favicon.ico">
<script type="application/ld+json">
{
  "@context": "http://schema.org", "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem", "position": 1,
    "item": { "@id": "../index.htm", "name": "Home" }
  },{
    "@type": "ListItem", "position": 2,
    "item": { "@id": "index.htm", "name": "Psion II" }
  },{
    "@type": "ListItem", "position": 3,
    "item": { "@id": "p1manfin.htm", "name": "Finance Pack Manual" }
  }]
}
</script>
</head>
<body>
<div class=header><h1>Jaap's Psion II Page</h1><a href="index.htm" class=jpp></a></div>
<ol class="breadcrumb">
  <li><a href="../index.htm">Home</a> /</li>
  <li><a href="index.htm">Psion II</a> /</li>
  <li>Finance Pack Manual</li>
</ol>

<h1>Psion Organiser Series 1:<br>THE ORGANISER FINANCE PACK</h1>

<hr>

<p>
The Psion Organiser and the plug-in Program
Packs and Datapaks form a sophisticated pocket
computer system containing digital electronic
components. They have been designed for ease of
use, but to ensure that you make me most or their
capabilities we suggest that you read this booklet,
in conjunction with your basic Organiser
handbook.
</p>

<p>
To avoid any possible damage, your organiser,
Program Packs and Datapaks should not be
exposed to extremes of temperature or humidity.
Do not subject them to hard knocks or excessive
force, nor immerse in liquids or use volatile fluids
when cleaning the case.
</p>

<h2>DISCLAIMER</h2>

<p>
Whilst all care has been taken in devising and
producing this Program Pack, neither Psion
Limited nor Psion Processors can accept any
liability whatsoever with respect to the use or
application of the Program and Programming
Language supplied in this Program Pack or of the
results of calculations utilising the facilities of this
Program Pack.
</p>

<p>
(C) PSION PROCESSORS LTD 1984
<br>DESIGN REGISTRATION APPLICATIONS
<br>NOS. 1019736 AND 1019737
<br>PATENT APPLICATION NO. 8412628
</p>

<hr>

<h2>CONTENTS</h2>

<ol>
<li><a href="#c1">INTRODUCTION</a>
   <br>Introduction; RUN; CAT; PROG; COPY; example
<li><a href="#c2">SCIENCE AND MATHS FUNCTIONS</a>
   <br>List of extra mathematical functions and utilities; using functions.
<li><a href="#c3">COMPOUND INTEREST</a>
   <br>Introduction; MORTGAGE, PAYMENTS, VALUE, CAPITAL, and DURATION programs.
<li><a href="#c4">CASHFLOW PROGRAMS &mdash; NPV, IRR</a>
   <br>Net Present Value and Internal Rate or Return programs.
<li><a href="#c5">DEPRECIATION</a>
   <br>Straight line depreciation DEPSL program; reducing balance depreciation DEPRB program.
<li><a href="#c6">BONDS AND EQUITIES</a>
   <br>Redemption yield of a semi-annual bond, BOND program; investment analysis, EQUITYPE program.
<li><a href="#c7">POPL &mdash; PROGRAMMING</a>
   <br>Introduction; writing a program; programming activities; PROG, EDIT, INSRT, QUIT, EXIT, SAVE, ERASE.
<li><a href="#c8">VARIABLES, INPUT, OUTPUT</a>
   <br>Variables; IN statement; OUT statement.
<li><a href="#c9">GOTO &mdash; LABELS, BRANCHING</a>
   <br>Branching: GOTO statement; line labels
<li><a href="#c10">CONDITIONS &mdash; IF STATEMENT</a>
   <br>Conditional statements: IF then GOTO; AND, OR, NOT.
<li><a href="#c11">LOOPING AND ITERATION</a>
   <br>Forming loops with IF and GOTO.
<li><a href="#c12">GLOBALS AND ARRAYS</a>
   <br>Local and Global variables; Arrays with STORE and RECALL.
<li><a href="#c13">CALLING PROCEDURES</a>
   <br>How to use procedures within procedures; passing parameters.
<li><a href="#c14">ERROR MESSAGES</a>
<li><a href="#c15">TROUBLESHOOTING</a>
<li><a href="#c16">WARRANTY</a>
</ol>

<hr>

<a id="c1"></a><h2>1<br>
INTRODUCTION</h2>

<p>
In the box containing this manual you will find a
program pack for the Organiser. The external
physical construction is identical to that of a
datapak and it plugs into your Organiser in exactly
the same way. Remove the datapak or dummy pak
from one of the drives of your Organiser by pulling
with your finger on the knurled outside of the pak.
Now insert the Finance Program Pack in the empty
slot in the normal way.
</p>

<p>
The Finance pack is a substantial software system
which turns the Organiser into a powerful tool for
business, financial, accounting and investment
needs. It contains a series of programs or
'procedures' especially designed to solve common
financial problems such as cash flow, depreciation
of compound interest. It also contains a
comprehensive list of mathematical functions
which are automatically added to the calculator
and which may also be used in programs.
</p>

<p>
However, most importantly it has been designed
as a potent means of customizing the Organiser to
your own specific needs and requirements. This is
achieved by the provision of a simple and easy-to-
use programming language in which you may write
your own programs or procedures, save them
permanently on your datapaks, and reuse them
whenever you need them for commonly occurring
problems that you deal with in your work or at
home. The Organiser is a complete pocket
computer, and the programming language POPL
allows you to apply it to your specific problems.
</p>

<p>
Once the program pack has been inserted into one
of the solid-slate drives of the Organiser, the range
of available activities is automatically extended.
Switch on the Organiser and press the
<b>MODE/HOME</b> key. In the basic Organiser, without
a program pack, the normal activities available
would be 'ENTER', 'CALC', 'OFF'. With the program
pack inserted, you will find additional activities
have been provided &mdash; press <b>MODE/HOME</b>
repeatedly to view them. These additional
activities are 'PROG', 'CAT', COPY' and 'RUN', and
they perform the following functions.
</p>

<h3>RUN &mdash; Running a program or procedure.</h3>

<p>
To run a program or procedure, select 'RUN', type
its name and press <b>EXECUTE</b>. The procedure or
program must either be one provided in the
program pack or one that you have stored in the
datapak currently fitted.
</p>

<h3>CAT &mdash; Cataloguing or finding procedures</h3>

<p>
'CAT' is used to list or find procedures from the
program pack or from the currently-fitted datapak.
It operates on procedure names in exactly the
same way as 'FIND' operates on records made
with the <b>SAVE</b> key.
</p>

<p>
Input a search clue in 'CAT' and press <b>EXECUTE</b>
and the Organiser will retrieve all program or
procedure names which include the search clue.
For a list of every program and procedure name
simply leave out the search clue and press
<b>EXECUTE</b> repeatedly &mdash; the Organiser will list the
programs and procedures from the program pack
first and then any in an attached datapak.
(Incidentally, some of the procedures you find this
way are specifically for use within others and
cannot be run independently.) When a procedure
has been found by executing 'CAT', the Organiser
will retain that procedure or program in temporary
storage so that you may switch into 'RUN', 'PROG'
or 'CALC'.
</p>

<h3>PROG</h3>

<p>
'PROG' is the Organiser activity for writing, editing,
and saving your own procedures or programs that you have
written. 'PROG' itself contains a menu of activities.
These and the use of 'PROG' are described in
detail in Chapter 7 and need not concern us now.
</p>

<h3>COPY &mdash; to copy datapak contents</h3>

<p>
'COPY' is a utility which allows you to copy the
entire contents (All), or the records (Records), or
the procedures (Procedures) of one datapak to
another. 'COPY' always copies from the datapak in
drive 1 (the one nearest the display window) to the
datapak in drive 2. When <b>EXECUTE</b> is pressed in
this activity, the organiser instructs you to remove
the program pack. Once you have done this you
must place the datapak from which you wish to
copy into drive 1 and an empty or newly-formatted
datapak in drive 2. When you have done this the
'COPY' utility will ask you whether you wish to
copy the entire contents (All), or records of
information (Records) or procedures (Procedures)
only. Press A, R, or P. The Organiser will now copy
from the datapak in drive 1 to the datapak in drive
2 according to your instructions, and leaving out
all erased records or procedures.
</p>

<h3>Running and looking at a program</h3>

<p>
To demonstrate how simple it is to use the
Organiser's Science program pack, we shall find,
run and list a procedure. With the program pack in
drive 1, press <b>ON/CLEAR</b> and use the
<b>MODE/HOME</b> key to select 'CAT'. Now type in the
letters BOH and press <b>EXECUTE</b>. The Organiser
will automatically find the procedure called
MORTGAGE and you will see the program name in
the display.
</p>

<p>
The MORTGAGE procedure is one of the financial
programs in the program pack and evaluates the
monthly repayments on a conventional repayment
mortgage. Press the <b>MODE/HOME</b> key until the
activity changes to 'RUN'. The program name
'MORTGAGE' will still be shown to the right of the
'RUN:' indicator. Press <b>EXECUTE</b> to run the
program.
</p>

<p>
The Organiser will now prompt you for the amount
of the loan concerned. Enter a number and press
<b>EXECUTE</b>. The Organiser will now ask you for the
interest rate which it is to apply. Enter the
percentage interest rate and press <b>EXECUTE</b>. You
will now be asked for the duration of the loan in
years. Enter a number and press <b>EXECUTE</b>.
Finally you will be asked whether the loan is from a
building society or bank. Enter 0 or 1 and press
<b>EXECUTE</b>. The Organiser will evaluate the
monthly repayments and print out the result on the
screen. This could apply, for example, to mortgage
repayments on a &pound;25,000 loan, spread over 20
years and payable monthly throughout the duration
of the loan.
</p>

<p>
Alter you have run this procedure in the manner
described above, you may wish to read how the
program is written in the Organiser's own
programming language &mdash; POPL. Press the
<b>MODE/HOME</b> key until 'PROG' is displayed. Now
press <b>EXECUTE</b>. The activity indicator will change
to 'EDlT:', and the procedure name 'MORTGAGE' will
be shown to its right. Press the <b>FIND</b> key, and you
will see the next line of the procedure. This is the
second function of the <b>FIND</b> key, (only applicable
in 'PROG') and is indicated by the blue arrow
below the key. Keep pressing the <b>&darr;</b> key to see each
line of the procedure in turn. Do not worry at this
stage about the meaning of each of the lines. They
are described in detail in chapters 7-13.
</p>

<p>
We have seen how to find programs or procedures,
how to recall them and run them, and we have
peeked into the language itself. The power of the
Organiser has been hugely advanced through the
Science program pack. The chapters below
describe all the scientific procedures supplied in
your program pack and describe how to write, and
save for repeated use, your own procedures. The
program pack has also, however, enhanced the
power of the calculator activity 'CALC', by a large
range of mathematical functions. These and their
use are described in Chapter 2.
</p>

<hr>

<a id="c2"></a><h2>2<br>
SCIENCE AND MATHS FUNCTIONS</h2>

<p>
When the Finance pack is attached to the
Organiser through one of the solid-state drives, a
comprehensive range of mathematical functions
automatically becomes available in CALC. Any of
these functions may be used in everyday
calculations simply by typing its name with a
numerical argument or arguments (i.e. the number
or numbers on which it is to operate) They may
also be used with numbers or variables in
programs (see Chapters 7-13). They are listed
below under the abbreviated names which the
Organiser recognizes. The number of arguments,
or parameters, each one requires is shown below
in parentheses.
</p>

<p><b>
Note that all angles are measured in radians
except for the purposes of the conversion
functions DEG and RAD.
</b></p>

<table summary="Functions">
<tr><td>LOG  </td><td>(1)</td><td>Log to the base ten of the given number. Input must be greater than zero.</td></tr>
<tr><td>ALOG </td><td>(1)</td><td>Antilog. The result at raising ten to the given power.</td></tr>
<tr><td>LN   </td><td>(1)</td><td>Log to the base e where e = 2.7183 corrected to four decimal places. Input must be greater than zero.</td></tr>
<tr><td>EXP  </td><td>(1)</td><td>Exponential value. Raises e to the given power.</td></tr>
<tr><td>SQRT </td><td>(1)</td><td>Square root. No negative values accepted.</td></tr>
<tr><td>SIN  </td><td>(1)</td><td>Sine of an angle</td></tr>
<tr><td>COS  </td><td>(1)</td><td>Cosine of an angle</td></tr>
<tr><td>TAN  </td><td>(1)</td><td>Tangent of an angle. Organiser registers an error if the angle yields an infinite tangent, e.g. PI/2 radians (90 degrees), 3PI/2 rads, 5PI/2 rads, etc.</td></tr>
<tr><td>ASN  </td><td>(1)</td><td>Arcsine. The angle whose sine, which must lie between -1 and 1, is given.</td></tr>
<tr><td>ACS  </td><td>(1)</td><td>Arc cosine. The angle whose cosine, which must lie between -1 and 1, is given.</td></tr>
<tr><td>ATN  </td><td>(1)</td><td>Arctangent. The angle whose tangent is given.</td></tr>
<tr><td>ABS  </td><td>(1)</td><td>Absolute value. Converts a negative number to a positive one. e.g. ABS(-5)=5.</td></tr>
<tr><td>INT  </td><td>(1)</td><td>Integer value. Rounds down to whole number. e.g. INT(1.8451)=1</td></tr>
<tr><td>DEG  </td><td>(1)</td><td>converts radians to degrees.</td></tr>
<tr><td>RAD  </td><td>(1)</td><td>Converts degrees to radians.</td></tr>
<tr><td>MOD  </td><td>(2)</td><td>Modulo. Calculates the remainder after dividing the first parameter by the second. e.g. MOD(20,8) is translated into 20-8*INT(20/8) which
               works out as 4, so that MOD(20,8)=4. The second parameter must not be equal to zero.</td></tr>
<tr><td>SINH </td><td>(1)</td><td>Hyperbolic Sine. e.g. SINH(5) returns the result of (EXP(5)-EXP(-5))/2.</td></tr>
<tr><td>COSH </td><td>(1)</td><td>Hyperbolic Cosine. e.g. COSH(5) returns the result of (EXP(5)+EXP(-5))/2.</td></tr>
<tr><td>TANH </td><td>(1)</td><td>Hyperbolic Tangent. e.g. TANH(5) returns the result at SINH(5)/COSH(5).</td></tr>
<tr><td>MIN  </td><td class=nowrap>(1 to 42)</td><td>Minimum. Finds the smallest of the values given.</td></tr>
<tr><td>MAX  </td><td class=nowrap>(1 to 42)</td><td>Maximum. Finds the greatest of the values given.</td></tr>
<tr><td>FAC  </td><td>(1)</td><td>Factorial e.g. FAC(5) is 5*4*3*2*1, so that FAC(5)=120. Input must lie between zero and 69.</td></tr>
<tr><td>SGN  </td><td>(1)</td><td>Sign. Looks at the sign at the given number. Its result is +1 if the number is positive, -1 if it is negative, and zero if it is zero.</td></tr>
<tr><td>ROUND</td><td>(1)</td><td>Rounds input to nearest integer, (0.5 is rounded up)</td></tr>
<tr><td>MEAN </td><td class=nowrap>(1 to 42)</td><td>Calculates the mean of the input values.</td></tr>
<tr><td>STDEV</td><td class=nowrap>(1 to 42)</td><td>Standard Deviation (n-1 basis) of the input values.</td></tr>
</table>

<h3>&quot;UTILITIES&quot;</h3>

<table summary="Utilities">
<tr><td>PI       </td><td></td><td>Needs no parameters. Produces the value of the Constant pi. which is 3.1416 (corrected), to be used in calculation like any other number.</td></tr>
<tr><td>**      </td><td>(0)</td><td>Simply type two multiplication signs together to call this operation. Raises the number to its left to the power given by the number to its right. e.g. 3**2 = 9.</td></tr>
<tr><td>RND     </td><td>(2)</td><td>Random number generator. Returns a random number in the range bounded by the two inputs, inclusive or the greater but excluding the lesser. For instance, RND(5,20) may produce any number from 6 to 20 inclusive. These random numbers are random in terms of distribution, but actually depend on a mathematical formula.</td></tr>
<tr><td>RAND    </td><td>(1)</td><td>Randomize. Sets the starting value for the formula which generates random numbers. This determines the series of random numbers that will result from subsequent uses at RND. For example, an input RAND(2) always results in the same series at random numbers, which is different from that resulting from say RAND(4). RAND(0) results in an arbitrary starting value for the random number generator, and will give a different series every time.</td></tr>
<tr><td>ENG     </td><td>(1)</td><td>Engineering Format. Sets format of output to a number between 1 and 999 times 10 to a power which is a multiple of three. For example, 0.56 is expressed as 560 E-3. and 56780000 as 56.78 E6. To set this format on, type in ENG(1) and press <b>EXECUTE</b>. To set it off type ENG(0). The current setting is active even when running procedures unless your procedure contains a statement to override it.</td></tr>
<tr><td>FIX     </td><td>(1)</td><td>Sets the number of places after the decimal point for any subsequent output. A negative input with FIX clears the last setting leaving the number of decimal places open.</td></tr>
<tr><td colspan=3>NOTE - Both ENG and FIX return their previous status as a result.</td></tr>
<tr><td>GETKEY   </td><td></td><td>Results in the ASCII code value of the next key pressed. Needs no parameters.</td></tr>
</table>


<p><b>
Don't forget, you can add to the functions your
Organiser can carry out, by writing your own
procedures.
</b></p>

<h3>Using Functions</h3>

<p>
First select 'CALC' Now type the name of the
function you want to use, followed by the correct
number of parameter values enclosed in brackets
Press <b>EXECUTE</b> to calculate the result.
</p>

<p>
A parameter value can be a number or the name
of a function or procedure which results in a
number. When you need to enter two or more
parameters you should separate each one from
the next by a comma, e.g.
</p>

<p class=program>MIN(7,9,4,PI,2,10)</p>

<p>
Functions can be linked by arithmetical operators,
just as numbers in a basic arithmetical
calculation, so that calculations such as:
</p>

<p class=program>COS(PI/3) * (SIN(2*PI)+ LN(2))-15/2 * COS(10)</p>

<p>
are well within Organisers capabilities.
</p>

<p>
An outstanding feature of the program pack is that
it allows you to do calculations which use the
result of one function or procedure as a parameter
value for another. This facility also means that
calculations may consist of functions stacked
within each other like a set of Chinese boxes. For
instance:
</p>

<p class=program>DEG(ASN(4/(SQRT(9+16))))</p>

<p>
Later, when you write your own procedures, you
will be able to stack them up in the same way,
combining them, if you wish, with the ready-made
functions.
</p>

<hr>

<a id="c3"></a><h2>3<br>
COMPOUND INTEREST</h2>

<h3>Introduction</h3>

<p>
The next four chapters describe a series of
programs already written and available for
immediate use from the Finance pack. They are
written in the Organiser's own programming
language and are executed or RUN through the
'RUN' activity. (They may also be run or evaluated
like library functions through the 'CALC' activity).
</p>

<p>
To execute them press the <b>MODE/HOME</b> key until
the 'RUN' indicator is shown and enter the full
name of the program. Then press the EXECUTE
key. The programs may also be found more simply
through the 'CAT' activity (see chapter 1).
</p>

<p>
In this chapter a series of programs to evaluate
compound interest problems are described. The
simplest of these is the evaluation of a monthly
mortgage repayment.
</p>

<h3>MORTGAGE &mdash; monthly repayments</h3>

<p>
This program will prompt the user for the initial
capital size of the mortgage, the interest rate to be
applied, and the duration of the mortgage in years.
in response to each prompt displayed by the
Organiser you should enter the appropriate
number and press the <b>EXECUTE</b> key. Do not enter
a non-numerical character. The program now
prompts you as to whether the mortgage is from a
building society or from a bank or other institution.
Enter 0 for a building society and 1 otherwise. The
program will then evaluate the monthly repayment
amount and show the amount on the screen.
</p>

<p>
At the end of the duration of the mortgage, the
program assumes that all capital and interest has
been paid. The distinction between building
societies and other loan institutions arises from
the different treatment of compound interest by the
building societies. The latter charge the full
interest on the principal at the beginning of the
year throughout the year and only reduce the
principal at the end of each year. The total interest
and repayment for the year are simply divided by
12 to give the monthly mortgage. Other financial
institutions usually reduce the principal on a
monthly basis.
</p>

<h3>PAYMENTS &mdash; between an initial and final capital flow</h3>

<p>
This and the following three programs are more
general programs than the special case of
mortgage repayment, and apply to the general
compound interest problem which governs many
financial transactions, decisions or evaluations.
</p>

<p>
The compound interest problem is defined as:
</p>

<p class=indent>
V = CAPITAL FLOW AT START OF PERIOD<br>
C = CAPITAL FLOW AT END OF PERIOD<br>
P = AMOUNT OF PAYMENTS AT REGULAR INTERVALS DURING PERIOD<br>
Y = DURATION OF PERIOD IN YEARS<br>
I = INTEREST RATE AS A PERCENTAGE<br>
N = NUMBER OF PAYMENTS PER YEAR<br>
K = 0 OR 1 FOR PAYMENTS AT END OR BEGINNING OF PAYMENT INTERVALS
</p>

<p class=indent>
let i = I/(100*N) then solutions are found for
the equation:
</p>

<div align=center>
<img src="pics/p1manfin/payments.gif" width=388 height=60 alt="">
</div>

<p>
I, N and Y must be positive numbers. For different
problems C, V and P may be positive or negative.
The sign convention used is that cash in (whether
capital or payment) is positive while cash out is
negative.
</p>

<p>
The program PAYMENTS solves the equation for P,
given V, C, I and N. On RUNning the program, the
Organiser will prompt you for the capital sum at
the start, the capital sum at the end, the number of
payments per year, the interest rate to apply and
the duration in years of the transaction. Type in
numerical answers to each question and press
<b>EXECUTE</b>. Use the negative sign preceding the
number if the capital sums are cashflows out. The
amount of each payment to be made at each
interval will be evaluated and shown on the screen.
A negative sign in the result shows that the
payments are cashflows out. The parameter K is
set to zero unless the capital at the start V is zero.
</p>

<p>
This program may be used to find the payments for
a mortgage, the payments for the redemption of a
loan with or without a final capital payment, the
payments required to accrue a given capital sum
through regular savings, hire purchase payments
and many others.
</p>

<h3>VALUE &mdash; present value of future income and capital</h3>

<p>
For the compound interest equation above, this
program evaluates present value V after the
Organiser prompts the number of payments per
year N, the duration of the transaction Y, the
percentage interest rate to be applied I, the capital
sum at the end of Y, and the amount of each
payment. Enter the appropriate number and press
<b>EXECUTE</b> in response to each query. Remember
that cash in is positive and cash out is negative.
</p>

<p>
The program may be used to estimate the value of
a financial asset or liability.
</p>

<h3>CAPITAL &mdash; sum at the end of a transaction</h3>

<p>
This program again solves the general compound
interest problem above for C, given V, P, N, I and Y.
K is taken as 1 if the starting capital V = 0 and
otherwise 0. The program prompts the user for all
inputs.
</p>

<p>
Many applications exist for this problem including
the capital accrued from regular savings, the
redemption value of a loan or bond and the future
value of a variety of financial assets and
transactions.
</p>

<h3>DURATION &mdash; time to repay a loan</h3>

<p>
Again, this is the solution of the general compound
interest problem above for Y, given N, I, V, and C.
For example, it will answer the question &quot;How
many years will it take to repay a loan V with fixed
payments P made N times a year and an interest
rate of I&quot;. RUN the program in the normal way and
the Organiser will prompt for all the variables. The
result in years will be shown on the screen.
Remember that cash flow in is positive and
cashflow out is negative. There are many cases
where the problem does not have a solution (an
infinite period or, worse, where the capital grows).
Ensure the data is meaningful.
</p>


<hr>

<a id="c4"></a><h2>4<br>
CASHFLOW PROGRAMS &mdash; NPV and IRR</h2>

<p>
Business and investment demand the use of
capital outflows in the hope of later cash inflows.
There are a number of criteria commonly used to
estimate the merit or worth of such an
investment. The two most common criteria are
<b>NET PRESENT VALUE &mdash; NPV</b> and <b>INTERNAL
RATE OF RETURN &mdash; IRR</b>. The Net Present Value
puts a current capital value to the discounted
cash flows, both in and out, of such an investment
where a &quot;going&quot; interest rate is assumed. IRR on
the other hand, answers the question &quot;What is the
effective percentage rate of return of the
investment given that the capital value prior to the
start of investment is zero?&quot;. The Organiser
will solve each of these problems through the
programs MPV and IRR.
</p>

<p>
Enter NPV or IRR when in the 'RUN' activity and
press <b>EXECUTE</b>. These programs assume regular
periods between cash payments and the
programs prompt for the duration of each period
expressed in months. To ease input of data, the
cashflow is broken into groups where each group
has a number of payments and an amount for
each payment.
</p>

<p>
The programs will prompt for the number of such
groups. For each such group, you will be
prompted for the number of payments it
comprises, and the amount of each individual
payment within it. Enter the appropriate number
in each case and press the <b>EXECUTE</b> key.
<b>Remember to enter cashflows in as positive
and cashflows out as negative.</b>
</p>

<p>
If the program is IRR, the interest rate of return
will be evaluated and the result shown on the
screen expressed as a percentage. If the net
cashflow is negative, no result can be evaluated.
</p>

<p>
If the program is NPV, the user will be prompted
for the &quot;going interest rate&quot; and the discounted
current capital value of the project will be
evaluated. You will be asked further as to whether
you would like to obtain the IRR for the entered
cashflow. Enter 0 for yes or 1 for no. Further NPV
calculations will be allowed for different &quot;going
interest rates&quot;.
</p>

<hr>

<a id="c5"></a><h2>5<br>
DEPRECIATION</h2>

<p>
Depreciation may be calculated by the straight
line method or by the method of reducing balance.
</p>

<h3>DEPSL &mdash; Straight Line</h3>

<p>
The straight line method of depreciation assumes
a fixed depreciation charge over the lifetime of the
asset. Upon RUNning DEPSL you will be
prompted for the purchase cost of the asset and
the scrap value of the asset at the end of its
lifetime expressed in years. The percentage
annual rate of depreciation will be calculated and
shown. Press the EXECUTE key and the
depreciation charge for each year will be shown.
</p>

<h3>DEPRB &mdash; Reducing Balance</h3>

<p>
This method assumes a fixed rate of depreciation
but varies the charge each year according to the
book value at the beginning of the year. Upon
RUNning DEPRB you will be prompted for whether
you wish to calculate the depreciable life of an
asset for a known rate, or the rate, given a known
life.
</p>

<p>
Enter 0 or 1 respectively. If you enter 0, you will
be asked to enter the rate of depreciation as a
percentage. The program will then evaluate and
show the lifetime of the asset. If you enter 1, the
program will ask for the lifetime of the asset and
evaluate the depreciation rate.
</p>

<p>
After these results are shown in the display, press
<b>EXECUTE</b>. The program will show the
depreciation charge for each year and the book
value at the end of the year. Press <b>EXECUTE</b> to
continue the calculation at any stage.
</p>

<hr>

<a id="c6"></a><h2>6<br>
BONDS AND EQUITIES</h2>

<h3>BOND &mdash; Redemption Yield</h3>

<p>
The program BOND evaluates the redemption
yield on a bond with two payments a year, given
the number of days to the next interest payment,
the coupon payment in each half year, the market
price, and the number of half years to the
redemption date. Select 'RUN', type 'BOND' and
press <b>EXECUTE</b> to start the program. The
program will prompt for each variable. Note that
the redemption period is expressed in complete
half years and does not include the time from the
current date to the next interest date. The latter
must be entered in days. The redemption yield as
a percentage will be evaluated and shown on the
screen. The program solves for the yield with
precision using iteration.
</p>

<h3>EQUITYPE</h3>

<p>
This program uses a 'Whitbeck-Kisor' model to
arrive at an estimated price to earning ration for an
equity on the UK stock market as of June 1984.
<b>WARNING</b>: this program is illustrative and is
based on a model. The program can be read in
'EDIT' and varied and saved for changing
circumstances.
</p>

<p>
The model is a simple one based on
statistical analyses showing the dependence of
equity prices on growth (G), dividend cover (C)
and fluctuations of profits (F). Execute the
program through <b>RUN: EQUITYPE</b>. The program
will prompt the user for estimates of the above
variables on a particular equity. Enter the
estimates in turn and press <b>EXECUTE</b>. The
program will then evaluate and show an expected
price to earning ratio.
</p>

<hr>

<a id="c7"></a><h2>7<br>
POPL &mdash; Programming Your Organiser</h2>

<h3>Introduction</h3>

<p>
Programming your Organiser is as simple as all of
the other Organiser operations, and yet enables
you to perform sophisticated and complex tasks
tailored exactly to your requirements. This is
achieved with the Psion Organiser Programming
Language (POPL) &mdash; a unique language which
takes full advantage of the Organiser's ability to
make things simple.
</p>

<p>
As with all Organiser operations. the line is still
the base unit of information, but with POPL you
can string together lines of instructions as a
sequence of steps for the Organiser to follow. A
complete series of steps is defined as a
procedure, and is given a unique name so that
you can save, recall, calculate, run and edit it.
Procedures are the building blocks in Organiser's
modular programming language, and they can be
combined, cross-referenced and generally used in
a flexible manner to produce a sophisticated
program.
</p>

<p>
Even the most complex and ambitious task can be
split down into a series of manageable elements
using this approach.
</p>

<h3>Writing a procedure</h3>

<p>
First, decide exactly what you want your
procedure to accomplish. Then examine the task
in detail to establish what steps are necessary to
complete it. If it is very complicated, break it
down into manageable sections, and tackle each
one separately. Each section can then be a
procedure in its own right with a unique name.
</p>

<p>
As a first step in writing a procedure it is often
useful to split the task into three parts; data you
need to feed in; how it is to be processed; and
data you want to get out. It is then easier to think
clearly and logically about the detail of the
procedure.
</p>

<p>
When you are deciding on the steps which will
make up the procedure, remember that computers
rely entirely on our instructions, which they
follow in the order of occurrence. The Organiser is
designed to point out many possible mistakes. but
it cannot supply instructions which you omit, or
decide that although you have written one thing
you really mean another! So, always be sure to
include, <i><b>in strictly logical sequence</b></i>, every
action involved in performing the task, not
forgetting to make provision for the Organiser to
read in any necessary information. Whenever you
write an instruction, consider what must be done
before it can be obeyed, and check that previous
instructions make the necessary provisions.
</p>

<h3>PROGRAMMING ACTIVITIES</h3>

<p>
The programming activities on the Organiser are
grouped in the activity 'PROG', so the first step is
to select 'PROG', using the <b>MODE/HOME</b> key.
This tells Organiser that you want to write a new
program or procedure or access an existing one
in order to edit, save or erase it. Now press
<b>EXECUTE</b> to show you are serious, Organiser will
briefly display the message &quot;ENTER PROG
NAME&quot; and then revert to the 'PROG:' indicator
and wait. Type in any procedure name, e.g.
TEMPCONV1 and press <b>EXECUTE</b>. Note that
procedure names must begin with a letter and
have a maximum of 16 characters. The name may
contain numbers but spaces and mathematical
operators are not allowed in procedure names.
</p>

<p>
If it is a new procedure, Organiser displays &quot;NEW
PROCEDURE&quot; briefly, then selects 'EDIT' and
gives you a new line ready for the first step in
your procedure. If you have typed the name of an
existing procedure its first line will be displayed
ready or you to edit it. In both cases, the activity
indicator 'EDIT:' is displayed. 'EDIT' is the activity
you will use for writing and editing procedures,
and it is always the first one presented within
'PROG'.
</p>

<p>
Now you can use the <b>MODE/HOME</b> key to select
any of the following range of activities concerned
with programming and the manipulation of
procedures. These are:
</p>

<table summary="">
<tr><td>'EDIT'</td><td>for writing and editing procedures. The
            <b>SAVE</b> and <b>FIND</b> keys take on new
            identities as <b>&uarr;</b> and <b>&darr;</b> respectively,
            allowing you to step up and down
            through the lines of a procedure. The
            chevron keys, &lt;&lt; and &gt;&gt; will still scroll
            the display horizontally so that you can
            read and edit a long line.
            <p>
            When you have typed a step of your
            procedure, press <b>&darr;</b> to move down to a
            new line for the next step. The first line
            is now in temporary storage. Press <b>&uarr;</b> to
            view or edit a previous line. When you
            edit a line, the new version replaces the
            old one in temporary storage.</td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr><td>'INSRT'</td><td>To insert a line above an existing one,
            bring the existing line into the display
            and select 'INSRT'. Enter your line of
            information and press <b>&darr;</b> to move down
            to the next line. You are now back in
            'EDIT'. 'INSRT' only allows you to insert
            one line at a time.</td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr><td>'QUlT'</td><td>discards your current edition (like
            <b>ON/CLEAR</b> but acting on a whole
            procedure) and selects 'ENTER'.</td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr><td>'EXIT'</td><td>takes you out of 'PROG' and carries
            your procedure into 'RUN' where you
            can try it out without delay. The
            procedure is retained in temporary
            storage until you replace it with another
            one or switch off.</td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr><td>'SAVE'</td><td>copies the edited procedure into
            permanent storage on a datapak for
            future reference</td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr><td>'ERASE'</td><td>erases (i.e. makes inaccessible) the
            procedure from the datapak. A copy of
            the procedure is retained in temporary
            storage, and the procedure name is
            carried into 'EDIT' in case you wish to
            edit and perhaps save it under the old
            name.</td></tr>
</table>

<p>
Like most Organiser activities, 'EXIT', 'QUIT',
'SAVE' and 'ERASE' do not take effect until you
press <b>EXECUTE</b>.
</p>

<p>
Within the current line, typing and editing
information are exactly as they were with the
basic Organiser, but when you are writing or
editing a procedure, all the lines you type go into
temporary storage, ready for immediate access.
</p>

<p>
Anything in temporary storage is lost when you
switch the Organiser off. When you write or edit
another procedure, the last one is automatically
discarded from temporary storage (This temporary
storage is simply a development of the way in
which the current line was retained in your basic
use of the organiser. As well as the current line
and the current procedure, it has space for
procedures and data called and created during
calculations involving the program pack.)
</p>

<p>
Note that the maximum length of any one line in a
procedure is 100 characters. The maximum length
of any one procedure is 200 bytes &mdash;
approximately 200 characters &mdash; but a program
can consist of as many procedures as you like,
and procedures can be nested or stacked within
each other. In this way you can write a program
several thousands of bytes (characters) long and
store it on a datapak.
</p>

<p>
Before you leave 'PROG', you may wish to copy
your current procedure into a datapak. To do this,
press <b>MODE/HOME</b> to select 'SAVE1:' or 'SAVE2:'
depending on which drive contains your datapak.
The procedure name is displayed with the 'SAVE:'
indicator for confirmation. If the datapak already
contains a procedure with that name. Organiser
briefly displays the message &quot;NAME IN USE&quot;
before the activity indicator appears. Before you
can save the current procedure, you must change
its name or erase the existing procedure from the
datapak. (For instance if you have edited a
procedure called GALS you might store the new
version under the name 'GALS2'.)
</p>

<p>
Note that when you save a procedure, it is stored
in a different way from that selected with the
<b>SAVE</b> key, so that it is invisible for the purposes of
'FIND'. Thus your personal records are not
cluttered with procedures and related data. A
procedure can only be accessed by entering its
name in 'CALC', 'PROG', 'CAT' or 'RUN'.
</p>

<p>
'PROG' is especially for programming activities,
so when you have finished working on a
procedure you must leave 'PROG' in order to
progress to something else. Your current work is
retained in temporary storage unless you discard
it using 'QUIT', If you want to use your procedure
straight away, you should 'EXIT' so that 'RUN' is
automatically selected. Both 'QUIT' and 'EXIT'
bring the current procedure name into the display
with the activity indicator, so that you can change
the name if you wish, or select another activity
within 'PROG'.
</p>

<p>
When you leave 'PROG' the current procedure
name is retained and displayed next time you
select 'PROG' (unless you used 'QUIT', when the
name is totally discarded).
</p>

<hr>

<a id="c8"></a><h2>8<br>
VARIABLES, INPUT, and OUTPUT</h2>

<h3>Variables</h3>

<p>
Within a program you will want to use numbers.
some of which are constants and can be written
as numbers in the program, and some of which
you will want to take different values each time
the program is run. The latter kind is called a
<b>variable</b> and is given a name consisting of a
single letter of the alphabet. Organiser reserves a
pigeon-hole in its memory for that variable, and
each time a new value is assigned to the variable
it puts the new value in the pigeon-hole. There is
more about variables in chapter 12.
</p>

<h3>IN</h3>

<p>
This is the input statement at POPL and causes
the organiser to read a numeric value from the
keyboard, and store it under the variable name
specified. This statement can take two forms: one
which just reads and stores the number you enter,
and another which makes the Organiser display a
message and wait for you to enter a number, and
then read and store the input. Note that whenever
Organiser prompts you to enter information you
must do so and then press <b>EXECUTE</b> to make it
continue.
</p>

<p>Examples:

<p class=program>IN L</p>

<p>
makes the Organiser display a question mark and
then wait for you to type a number and press
<b>EXECUTE</b>. It then reads and stores that number
under the name L.
</p>

<p class=program>IN &quot;NUMBER OF LITRES&quot; L</p>

<p>
makes Organiser display &quot;NUMBER OF LITRES?&quot;
and wait for you to type a number which it then
reads and stores as L. Note that the Organiser
supplies the question mark for you.
</p>

<h3>OUT</h3>

<p>
This is the output statement of POPL and causes
the Organiser to display the result of an operation.
with or without an accompanying message. Your
message text must be enclosed with quotation
marks, for example:
</p>

<p class=program>OUT L*0.22</p>

<p>
makes the Organiser display the result of
multiplying the current value of L by 0.22.
</p>

<p class=program>OUT &quot;GALS&quot; L*0.22</p>

<p>
makes it display the result with a caption &quot;GALS&quot;.
</p>

<p class=program>OUT &quot;HELLO MASTER&quot;</p>

<p>
makes it display that message of greeting.
</p>

<h3>Assignment</h3>

<p>
Assignment statements tell the Organiser what it
must do with the numbers and variables on the
right hand side of the = sign to compute the new
value of the variable on the left. Once computed,
the new value of the variable replaces the existing
one in the pigeon hole. For example, <b>C=3*(A+B)</b>
tells Organiser to add together the current values
of the variables A and B, and multiply the result by
three to compute the new value of the variable C.
</p>

<p>
Within an assignment statement you can use any
of the standard mathematical operators. + - * /,
or ** (which raises the preceding number to the
power of the following number). In addition you
may use any of the mathematical functions and
procedures provided on the Science Pack or ones
that you have written yourself, thus building up an
algebraic equation.
</p>

<p>
In many cases an assignment statement is
indistinguishable from an algebraic equation
However while, for instance. A=A+1 is
unacceptable as an algebraic equation, it is a
valid assignment statement, which tells the
Organiser to add one to the current value of the
variable A to compute the new value.
</p>

<h3>Example</h3>

<p>
With the IN and OUT statements. variables and
assignments, it is possible to write a whole
procedure:
</p>

<p class=program><u>GALS</u>

IN &quot;LITRES&quot; L
G=L*0.22
OUT &quot;GALLONS&quot; G</p>

<p>
When RUNning this program or executing it in
'CALC', you would be asked for the numbers of
litres with the prompt &quot;LITRES?&quot; and the answer
would be displayed as <b>GALLONS=answer</b>
</p>

<p>
In fact this program could have been made
shorter. A different assignment statement,
<b>= L*0.22</b> would have caused the Organiser to
finish the procedure at that line and still return the
same answer but with the procedure name as the
caption.
</p>

<p class=program><u>GALS</u>

IN &quot;LITRES&quot; L
=L*0.22</p>

<p>
would return <b>GALS=answer</b>
</p>

<hr>

<a id="c9"></a><h2>9<br>
GOTO&mdash;Branching and Labels</h2>

<p>
So far the Organiser has dealt with each line of a
program in strict sequence, step by step. However
in programming one often wants to redirect the
Organiser to different parts of the program, to
jump from one section to another. To do this you
need to be able to identify the line you wish to
jump to.
</p>

<p>
Labels are used as a means of identifying a
particular line in a program and are placed at the
beginning of the line. They can have any number
of characters, but must start with a letter and be
followed by a colon. For example the label 'HERE'
could he used like this <b>HERE:IN &quot;COST&quot; C</b>. For
reasons that will become apparent later, the
identifiers P1, P2, P3, P4, and P5 are reserved for
a special use and cannot be used as labels.
</p>

<h3>GOTO</h3>

<p>
This statement tells the Organiser to jump to a
particular line in the program, ignoring the lines in
between. GOTO must be used with a label as a
reference for the line to be jumped to.
</p>

<p>
For example:
</p>

<p class=program>
GOTO HERE
THERE:IN &quot;PRICE&quot; P
HERE:IN &quot;COST&quot; C
</p>

<p>
Organiser will jump to me line labelled 'HERE'.
without asking for the input 'PRICE'. Thus to
branch from one part of the program to another
one simply identifies the destination with a label
and uses the GOTO command to make the
Organiser jump to that branch. Another GOTO
elsewhere in the procedure would refer to the
label &quot;THERE&quot;.
</p>

<hr>

<a id="c10"></a><h2>10<br>
CONDITIONS&mdash;the IF statement </h2>

<p>
It is often desirable to have a statement in a
program that effectively says &quot;If something is true
Then GOTO a particular part of the program&quot;. This
is achieved in POPL with the IF statement, which
doesn't require you to type the &quot;then&quot;. For
example:
</p>

<p class=program>
IF V=10 GOTO HERE
</p>

<p>
which means that if the variable V has a value of
10 then the condition is true and the GOTO
instruction is followed. If the condition had been
false (i.e. V was not equal to 10) then the Organiser
would have ignored the GOTO instruction and
proceeded directly to the next line in the program.
</p>

<p>
This conditional statement can be used with the
Equals condition (=), with Less Than (&lt;), Greater
Than (&gt;) and Not Equal To (&lt;&gt;). All these
symbols are marked In blue on the keyboard and
(in common with the other blue symbols below
character keys) are accessed by pressing <b>SHIFT</b>
first.
</p>

<p>
The Less Than and Greater Than conditions can
be combined with the equality condition to
produce the conditions Less Than Or Equal To
(&lt;=) and Greater Than Or Equal To (&gt;=). For
example:
</p>

<p class=program>IF V&gt;=5 GOTO HERE</p>

<p>
means that if V has a value of 5 or more then the
Organiser will GOTO the line labelled 'HERE' and
continue executing the program from that point.
</p>

<p>
Before moving on to consider the use of logical
operators <b>AND</b>, <b>OR</b> and <b>NOT</b> we should first
explain a special case of the equality condition.
Where an IF statement uses a name without an
associated condition and says, for example: IF V
GOTO, then if V has a value of zero the condition
will be interpreted as false, and if V has a value
other than zero it will be interpreted as true and
the GOTO statement followed. This feature is very
useful since it is often important to follow different
actions depending on whether or not a variable
has a value of zero.
</p>

<h3>AND, OR and NOT</h3>

<p>
The IF statement can be extended to obey
multiple conditions using the AND, OR and NOT
operator, which are concerned with true and false
relationships.
</p>

<p>
<b>AND</b> is used to combine two conditions that must
both be met for the result to be true. For example
the statement A=5 AND B&lt;4 is false if either A
is not equal to 5 or B is not less than 4.
</p>

<p>
<b>OR</b> is used to combine two condition so that if
either or both are met then the result of the
statement is true. For example the statement A=5
OR b&lt;5 is true if either A is equal to 5 or if B is
less than 4.
</p>

<p>
<b>NOT</b> is used to make a true result false and a
false result true. For example NOT C=3 will return
a result of true if the expression C=3 is false (i.e..
C is not equal to 3).
</p>

<p>
These three logical operators can be combined in
just the same way as the mathematical operators
* / + - and **. Similarly they have an order of
preference of evaluation - the NOT operator is
evaluated first, and then the AND and OR
operators have equal precedence and are
evaluated in the order they appear on the line
from left to right. For example:
</p>

<p class=program>IF A=3 AND NOT B=4 OR C&lt;7 GOTO HERE</p>

<p>
would be calculated in this order: firstly the NOT
B=4 to give a result which we can call 'result 1';
then the expression A=3 AND 'result 1' would be
evaluated to give a 'result2'; finally the expression
'result 2' OR C&lt;7 would be evaluated to give a
result of true of false for the IF condition.
</p>

<hr>

<a id="c11"></a><h2>11<br>
LOOPING and ITERATION</h2>

<p>
Within a program it is often very important to be
able to repeat a series of instructions several
times. This may be because you wish to carry out
a particular evaluation several times, or because
you need to increment a variable repeatedly and
perform a calculation on it, or because you need
an iterative solution to an expression.
</p>

<p>
With POPL this is a very simple task using the
GOTO and IF statements. For example, a simple
procedure to calculate the factorial of a number is
shown below (note that in this program pack we
have actually given you a function which performs
this operation, so perhaps you might like to test
this procedure against the function!)
</p>

<p class=program>
<u>FACT</u>

IN &quot;NUMBER&quot; N
C=0
F=1
LOOP:C=C+1
F=F*C
IF C&lt;N GOTO LOOP
OUT &quot;FACTORIAL IS &quot;F
</p>

<p>
In this procedure the loop is used to increment
the counter C. The factorial is evaluated
recursively by multiplying the variable F by each
successive value of C. When C=N the loop is
ended (The definition of Factorial N is
N*(N-1)*(N-2)*...1 ).
</p>

<p>
There are many uses of loops in the programs
supplied with this program pack, so for further
examples just examine these programs using the
'EDIT' activity.
</p>

<hr>

<a id="c12"></a><h2>12<br>
GLOBALS and ARRAYS - STORE, RECALL</h2>

<p>
So far we have only said that variables must have
a name consisting of a single character, thus
giving a maximum of twenty-six variables. In fact
these variables are said to be <b>local</b> to the
procedure in which they occur. That is, you can
use the same variable name again in a different
procedure without it affecting the variable in the
original procedure.
</p>

<p>
However, it is often desirable to have some
variables which are <b>global</b>, that is, variables that
are accessible to every procedure &mdash; so that if
you alter the value of, say, A then any other
procedure using A will read the altered value.
</p>

<p>
This is achieved In POPL with the STORE and
RECALL functions, also providing a convenient
method of storing a series at repetitive inputs or
results. STORE is a function that has two
arguments &mdash; an index number and the value you
wish to store. For example, STORE(1,5.6) will put
the number 5.6 in temporary storage at a location
with an index number of 1. The value stored is
then accessible from all procedures, it is a global
reference. To retrieve the number use the RECALL
function, which has just one argument, the index
number. For example A=RECALL(1) will make the
variable A equal to the number stored in index
position 1.
</p>

<p>
The index number can be any whole number
between 1 and 20 inclusive, thus there is capacity
to STORE twenty values in this way.
</p>

<p>
STORE and RECALL can be used very
conveniently when you wish to handle a series of
numbers, such as inputs or calculation results.
For example, examine the following three
procedures which deal with data input,
manipulation and output separately:
</p>

<p class=program><u>INPUT</u>

IN &quot;No. OF VALUES (LESS THAN 10)&quot; N
I=0
LOOP:I=I+1
OUT &quot;VALUE&quot; I
IN &quot;VALUE IS&quot; V
STORE(I,V)
IF I&lt;N GOTO LOOP</p>

<p class=program><u>CALCULATION</u>

IN &quot;NO. OF CALCS (LESS THAN 10)&quot; N
I=0
LOOP:I=I+1
A=RECALL(I)
R=A/2
STORE(I+10,R)
IF I&lt;N GOTO LOOP</p>

<p class=program><u>OUTPUT</u>

IN &quot;HOW MANY RESULTS&quot; N
I=0
LOOP:I=I+1
A=RECALL(I)
OUT &quot;FOR INPUT&quot; A
B=RECALL(I+10)
OUT &quot;RESULT IS&quot; B
IF I&lt;N GOTO LOOP</p>

<p>
These procedures could be combined in one
program called EXAMPLE
</p>

<p class=program><u>EXAMPLE</u>

INPUT
CALCULATION
OUTPUT</p>

<p>
This program would execute each of the
procedures in turn.
</p>

<hr>

<a id="c13"></a><h2>13<br>
CALLING PROCEDURES</h2>

<p>
As we have said earlier the basic building block of
programs written in POPL is the procedure, and
procedures can be nested or stacked within each
other. The process of using one procedure within
another is named 'calling a procedure'. Thus the
program 'WAGES' might call the procedure 'DAYS'
to calculate the number of days between two
dates as part of a calculation of the wages of a
seasonal, temporary employee. The actual
mechanics of calling a procedure are very simple
&mdash; where the procedure is required just quote its
name, either on a line of its own or as part of an
expression. For example:
</p>

<p class=program><u>WAGES</u>

IN &quot;DAILY WAGE&quot; W
A=DAYS
P=A*W
OUT &quot;PAY IS &pound;&quot; P</p>

<p>
In this example 'DAYS' is a procedure. Before we
can talk any more about calling procedures we
need to discuss parameters.
</p>

<h3>Parameters</h3>

<p>
Although the term parameters may be unfamiliar
to you, you are in fact accustomed to using them.
For example, the operator + takes two
parameters, that is two numbers on which to
operate (note that these parameters can be
mathematical expressions themselves, just so
long as they return a numerical result for the + to
operate on). Another example is the SIN function
provided by this program pack &mdash;&mdash; you are asked
to use the function by putting in brackets the
number whose sin you want e.g. SIN(1.3). In the
same way, a procedure can be made to operate
on parameters to be written in brackets after the
procedure name.
</p>

<p>
Parameters are particularly useful when you want
to pass a number or result of a calculation from
one procedure to be used as the input in another
procedure. In one way they can be considered as
a substitute for variables, but the value of a
parameter does not change within a procedure.
Using parameters gives you the freedom to write
a procedure that can be used in other procedures
without having to coordinate the two procedures
to reference the same STORE index.
</p>

<p>
POPL allows you to pass five numbers,
parameters, from one procedure to another
without having to use STORE and RECALL.
Instead write the procedure using parameter
names P1, P2, P3, P4, and P5 for the values you
wish to be read from the parent procedure. For
example imagine a general purpose procedure
called 'GROSS' which converts a wholesale price
to a retail price including VAT and allows for a
discount to the retailer. You want to be able to
include this procedure in several different
programs. The procedure requires two
parameters, the wholesale price and the discount
rate, to be passed to it.
</p>

<p class=program><u>GROSS</u>

=1.15*P1/(1-P2/100))</p>

<p>
This procedure could be called from within a
program which calculates the retail price lot
different products, the relevant part of which may
look like:
</p>

<p class=program>
IN &quot;WHOLESALE PRICE&quot; W
IN &quot;DISCOUNT RATE&quot; D
R=GROSS(W,D)
OUT &quot;RETAIL PRICE IS &pound;&quot; R
</p>

<p>
This will call the procedure GROSS and pass the
values or W and D to the procedure as P1 and P2.
This example is in fact a rather trivial one which
could have been achieved without passing
parameters, however, it illustrates the principles. A
more sophisticated example which uses
parameters in an iterative loop, calling the
procedure itself again and again in the loop, is
shown below. In fact this example is another
procedure to calculate the factorial of a number
(similar to the one we used to demonstrate loops)
</p>

<p class=program><u>FACT</u>

IF P1&gt;0 GOTO LABEL
A=1
GOTO RET
LABEL:A=FACT(P1-1)*P1
RET:=A</p>

<p>
We could RUN or CALC this procedure to
calculate the Factorial of 6 by executing FACT(6),
but if we just executed FACT it would assume that
P1 should take a value of 0, and in this case
would give the result FACT(0)=1. This type of
procedure relies on being passed the input data it
requires in the form of PROCEDURE NAME(P1,
P2,P3,P4,P5). This differs from other procedures
we have met where the input data is requested
through INput statements. When calling
procedures from procedures the passing
parameters method is most commonly used,
however it is possible to write a procedure which
will accept passed parameters if they are given.
but will prompt for input it they are not given.
</p>

<p>
This ability to prepare a procedure to receive
numbers at the same time as it is called is
essential for combining several procedures in one
calculation. For instance the procedure:
</p>

<p class=program><u>EGG</u>

=15</p>

<p>
may be combined with
</p>

<p class=program><u>CHIPS</u>

=30</p>

<p>
and
</p>

<p class=program><u>DOUBLE</u>

=2*(P1)</p>

<p>
so that the calculation
</p>

<p class=program>DOUBLE(EGG+CHIPS)</p>

<p>
becomes possible. 'DOUBLE' takes one
parameter, written as P1 in the procedure, and to
get the number it calls and runs 'EGG', then it
calls and runs 'CHIPS' and adds the two results
together. Thus the final result here would be
2*45.
</p>

<hr>

<a id="c14"></a><h2>14<br>
ERROR MESSAGES</h2>

<p>
The Organiser is able to detect many programming
errors before you try to RUN your program, and
brings them to your attention for you to take
remedial action. When it finds an error, the
Organiser displays a message describing the
nature of the error. Simply press the <b>ON/CLEAR</b>
key to clear the message and the offending line
will be displayed, with the cursor marking the
actual error. Correct the problem and continue.
</p>

<p>
Those errors which need a little more explanation
than is possible in a sixteen character error
message are detailed below:
</p>

<p>
<b>&quot;ILLEGAL NAME&quot;</b> &mdash; This message will come up
for three seconds to indicate that an inadmissible
procedure name has been used. All procedure
names must start with a letter and consist only of
letters and digits. The names P1, P2, P3, P4 and P5
are reserved as parameter names.
</p>

<p>
<b>&quot;NAME IN USE&quot;</b> &mdash; This message will come up for
three seconds if you try to SAVE a program or
procedure under a name which already exists on
the Program Pack or Datapak. Either edit the name
or ERASE the old program or procedure.
</p>

<p>
<b>&quot;LABEL NOT FOUND&quot;</b> &mdash; This means that the
Organiser was unable to find the label referred to
in a GOTO statement. Press <b>ON/CLEAR</b> to clear
the message and get back to the line in which the
GOTO occurs.
</p>

<p>
<b>&quot;DATAPAK FULL&quot;</b> &mdash; means that the datapak to
which you were trying to SAVE is full. Press
<b>ON/CLEAR</b> and insert a different datapak which
has sufficient space remaining.
</p>

<p>
<b>&quot;PROGRAM NOT FOUND&quot;</b> &mdash; means that you
have tried to RUN, CALC, CAT, PROG or call a
program or procedure that does not exist on either
the program pack or the datapak fitted. Clear the
message with <b>ON/CLEAR</b> and either correct the
name or replace the datapak with the one that
contains the program and try again.
</p>

<p>
<b>&quot;PROGRAM TOO LONG&quot;</b> &mdash; means that a
program or procedure has exceeded the limit of
200 bytes (approximately 200 characters). Clear
the message with <b>ON/CLEAR</b> and reduce the
length of the program concerned. This is in fact
quite simple to do by splitting the program or
procedure into smaller procedures, each less than
200 bytes long, or by making the program more
efficient (consider reducing the length of any
output text).
</p>

<p>
<b>&quot;OUT OF MEMORY&quot;</b> &mdash; means that the
combination of the program and variables held in
temporary storage has exhausted the amount of
temporary storage available on the Organiser.
Clear the message with <b>ON/CLEAR</b> and edit your
programs and data to occupy less space. Apart
from making your program more efficient you can
save memory by calling fewer procedures from
within procedures because each one takes up a
small overhead of space.
</p>

<hr>

<a id="c15"></a><h2>15<br>
TROUBLESHOOTING</h2>

<h3>
Nothing is Happening
</h3>

<p>
If nothing appears to be happening when you
expect otherwise, this could be because:
</p>

<p>
1. The Organiser is waiting for you to respond to an
input request (the cursor is flashing) &mdash; type a
number and press <b>EXECUTE</b>.
</p>

<p>
2. The Organiser has displayed an output and is
waiting for you to press <b>EXECUTE</b> to continue
with the next step of a program.
</p>

<p>
3. The Organiser is performing a calculation or
program &mdash; you must wait for the calculation to
be completed. Pressing <b>ON/CLEAR</b> will abort
the calculation. If you wish to chart the progress
of a program or procedure, insert output
statements at various points.
</p>

<p>
4. The Organiser has completed a calculation or
program and is ready for fresh instructions.
</p>

<p>
5. The Organiser is stuck in an infinite loop &mdash; this
will not occur for any of the programs supplied
on the program pack! Abort with the
<b>ON/CLEAR</b> key and edit your program.
</p>

<hr>

<a id="c16"></a><h2>16<br>
WARRANTY</h2>

<p>
Your Psion Organiser Program Pack carries a one
year warranty against mechanical or electrical
failure other than in the case of misuse or damage
arising from negligence. There are no
user-serviceable parts within your Program Pack,
and any attempt to dismantle or repair your
Program Pack other than by an Appointed Psion
Service Agent will invalidate this warranty.
</p>

<p>
Should you experience any problems consult your
manual with particular reference to the
troubleshooting section. If you find no solution to
your problem send your Program Pack in suitably
protective packaging to:
</p>

<p align=center>Service Dept.
<br>Psion Processors Ltd.
<br>22 Dorset Square
<br>LONDON NW1 6QG
</p>

<p>
We can accept no responsibility for goods
damaged in transit to us. This warranty does not
affect your statutory rights.
</p>


<hr>

<div class=nav><ul>
<li><a href="../index.htm">Home</a></li>
</ul></div>

</body>
</html>
